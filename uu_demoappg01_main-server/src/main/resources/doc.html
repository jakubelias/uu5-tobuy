<uu5string/>
<UU5.Bricks.Lsi.Item language="cs">
  <UU5.Bricks.Section header="Ukázka použití uuAppBinaryStore-Dao v technologii Java">
    <UU5.Bricks.P>
      V rámci ukázky je představena práce s uuBinaryDao na příkladu vkládání obrázků do uuAppBinaryStore.
    </UU5.Bricks.P>
    <UU5.Bricks.Section header="Ukázka konfigurace UuBinaryDao">
      <UU5.Bricks.Em>Konfigurace perzistence - slouží k inicializaci základních komponent pro práci s uuAppBinaryStore.</UU5.Bricks.Em>
      <Plus4U5.Bricks.SourceCode value='import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Import;
import org.springframework.data.mongodb.MongoDbFactory;
import org.springframework.data.mongodb.core.MongoTemplate;
import uu.app.binarystore.BinaryStoreContextConfiguration;
import uu.app.binarystore.dao.annotations.BinaryStore;
import uu.app.datastore.annotations.DataStoreConfiguration;
import uu.app.datastore.mongodb.AbstractMongoDbContextConfiguration;

/**
 * Spring configuration of the application persistence.
 */
@DataStoreConfiguration(maxNoa = 15)
@Import({
    BinaryStoreContextConfiguration.class
})
public class SubAppPersistenceConfiguration extends AbstractMongoDbContextConfiguration {

  @Value("${mongoDbConnectionUri}")
  private String connectionUri;

  @Bean({"primaryBinaryStoreFactory"})
  public MongoDbFactory primaryMongoFactory() {
    return getMongoDbFactory(connectionUri);
  }

  @BinaryStore(name = {"primaryBinaryStore"})
  public MongoTemplate primaryBinaryStore(MongoDbFactory mongoDbFactory) throws Exception {
    return getMongoTemplate(mongoDbFactory);
  }
}'>
      </Plus4U5.Bricks.SourceCode>
      <UU5.Bricks.P>Konfigurační třidu je nutné oanotovat <UU5.Bricks.Code>@DataStoreConfiguration</UU5.Bricks.Code>. V rámci této anotace je možné nastavit hodnotu maxNoa (defaultní hodnota je 10).</UU5.Bricks.P>
      <UU5.Bricks.P>V rámci třídy je inicializována hodnota connection stringu pro MongoDb, která je v ukázce načtena ze spring konfigurace.
        Dále jsou vytvořeny dvě beany pro práci s MongoDb a pomocí anotace jsou pojmenovány dle naší preference. Názvy těchto bean jsou pozdeji použity při definici Dao.</UU5.Bricks.P>
      <UU5.Bricks.P>! Pro správné fungování uuAppBinaryStore je důležité, aby beana pro MongoDbFactory byla pojmenována jako název beany pro MongoTemplate + "Factory". Při nedodržení tohoto pravidla nebude moci být Dao správně inicializováno a zahlásí chybu.
      </UU5.Bricks.P>
      <br/>
      <UU5.Bricks.Em>Entita Image - entita přebírá veškeré atributy z UuBinary. Neslouží k uchování jiných atributů - v takovém případě je nutné využít uuAppObjectStore.
        Entita image určuje, do jaké kolekce se v rámci MongoDb budou data ukládat (odvozeno od názvu třídy).</UU5.Bricks.Em>
      <Plus4U5.Bricks.SourceCode value='import uu.app.binarystore.domain.UuBinary;

public class Image extends UuBinary {
}'>
      </Plus4U5.Bricks.SourceCode>
      <br/>
      <UU5.Bricks.Em>Interface ImageDao - rozšiřuje rozhraní UuBinaryDao, kterému zároveň předává entitu, s níž bude pracovat. Zde je již možné definovat vlastní metody Dao, které zároveň mohou využívat protected metody zmíněné výše.</UU5.Bricks.Em>
      <Plus4U5.Bricks.SourceCode value='import uu.app.binarystore.dao.UuBinaryDao;
import uu.demoapp.main.domain.Image;

public interface ImageDao extends UuBinaryDao<Image> {
}'>
      </Plus4U5.Bricks.SourceCode>
      <br/>
      <UU5.Bricks.Em>Implementace ImageDao - třída implementující vlastní Dao. Slouží jednak ke konfiguraci základních atributů a dále pro implementaci vlastních dao metod.</UU5.Bricks.Em>
      <Plus4U5.Bricks.SourceCode value='import javax.annotation.PostConstruct;
import uu.app.binarystore.dao.annotations.BinaryStoreDao;
import uu.app.binarystore.dao.mongodb.UuBinaryMongoDbDao;
import uu.app.datastore.concurrency.ConcurrencyStrategy;
import uu.demoapp.main.dao.ImageDao;
import uu.demoapp.main.domain.Image;

@BinaryStoreDao(entityClass = Image.class, storage = "primaryBinaryStore", maxNoi = 10000, maxSoi = 10000, maxSob = 10000000, concurrency = ConcurrencyStrategy.REVISION)
public class ImageDaoImpl extends UuBinaryMongoDbDao<Image> implements ImageDao {

  /**
   * Creates schema on start. Does nothing if schema already exists in database.
   */
  @PostConstruct
  private void initializeSchema() {
    createSchema();
  }
}'></Plus4U5.Bricks.SourceCode>
      <UU5.Bricks.P>Konfigurace probíhá pomocí anotace <UU5.Bricks.Code>@BinaryStoreDao</UU5.Bricks.Code>. Atributy, které je možné konfigurovat:
      </UU5.Bricks.P>
      <UU5.Bricks.Ul>
        <UU5.Bricks.Li><UU5.Bricks.Code>entityClass</UU5.Bricks.Code> - povinný atribut, hodnotou musí být entitní třída, se kterou dao bude pracovat. Tato třída musí být potomkem UuBinary (případně je možné použít i samotnou třídu UuBinary).</UU5.Bricks.Li>
        <UU5.Bricks.Li><UU5.Bricks.Code>storage</UU5.Bricks.Code> - povinný atribut, hodnotou musí být název Spring beany obsahující instanci databázového enginu (v případě MongoDb je to MongoTemplate). Tato beana je definována v rámci konfigurace uuAppBinaryStore.</UU5.Bricks.Li>
        <UU5.Bricks.Li><UU5.Bricks.Code>maxNoi</UU5.Bricks.Code> - defaultní hodnota 100 000</UU5.Bricks.Li>
        <UU5.Bricks.Li><UU5.Bricks.Code>maxSoi</UU5.Bricks.Code> - defaultní hodnota 64 000</UU5.Bricks.Li>
        <UU5.Bricks.Li><UU5.Bricks.Code>maxSob</UU5.Bricks.Code> - defaultní hodnota 16 000 000 </UU5.Bricks.Li>
        <UU5.Bricks.Li><UU5.Bricks.Code>concurrency</UU5.Bricks.Code> - Použitá concurrency strategy. Je možné zvolit mezi NONE, REVISION a LOCK. Defaultní hodnota je REVISION.</UU5.Bricks.Li>
      </UU5.Bricks.Ul>
      <UU5.Bricks.P>Třída dědí od třídy <UU5.Bricks.Code>UuBinaryMongoDbDao</UU5.Bricks.Code>, která obsahuje implementaci všech základních operací pro práci s MongoDb a pomocí nich je tak zde možné realizovat implementaci vlastních metod definovaných v rámci rozhraní ImageDao.</UU5.Bricks.P>
      <UU5.Bricks.P>V ukázce je možné vidět použití anotace <UU5.Bricks.Code>@PostConstruct</UU5.Bricks.Code>, která spustí takto oanotovanou metodu po inicializaci třídy.
        V této metodě jsou pak vytvořeny všechny základní indexy popsané v této dokumentaci. Díky anotaci je tedy zajištěno, že se zkontrolují a případně vytvoří potřebné indexy při spuštění serveru.</UU5.Bricks.P>
      <br/>
      <UU5.Bricks.Em>Získání instance Dao</UU5.Bricks.Em>
      <Plus4U5.Bricks.SourceCode value='import javax.inject.Inject;
import org.springframework.stereotype.Component;
import uu.demoapp.main.dao.ImageDao;

@Component
public final class ImageModel {

  @Inject
  private ImageDao imageDao;
}'></Plus4U5.Bricks.SourceCode>
    </UU5.Bricks.Section>
    <UU5.Bricks.Section header="Práce s binárními daty v controlleru a modelu aplikace">
      <UU5.Bricks.P>
        S binární daty (či velkými daty), která chceme uložit do uuAppBinaryStore, je nutné na serveru pracovat streamovaně. Díky tomu zajistíme minimalizaci potřebné paměti k přenosu těchto dat, která se do paměti v případě velkých souborů ani nemusejí vejít.
      </UU5.Bricks.P>
      <UU5.Bricks.P>
        Binární, nebo velká data je nutné na server posílat ve formátu multipart/form-data (HTTP hlavička content-type), pak se UAF postará o to, aby se na serveru s daty dalo pracovat standardním způsobem, jako kdyby přišly data ve formátu application/json. Jediný rozdíl je, že atribut dtoIn, ve kterém jsou binární data, obsahuje objekt typu stream.
      </UU5.Bricks.P>
      <UU5.Bricks.P>
        Oproti nahrání dat, je při odeslání dat ze serveru potřeba zajistit aby se data ze serveru odeslali ve streamu (v takzvaných chunks) a musí se nastavit hlavičky content-type a content-disposition, aby bylo zajištěno správné chování prohlížeče při stažení dat (obrázek zobrazí, textový soubor stáhne na disk).
      </UU5.Bricks.P>
      <UU5.Bricks.Em>Ukázka controlleru pracujícího s binárními daty v technologii Java</UU5.Bricks.Em>
      <Plus4U5.Bricks.SourceCode value='package uu.demoapp.main.controller;

import static org.springframework.web.bind.annotation.RequestMethod.GET;
import static org.springframework.web.bind.annotation.RequestMethod.POST;

import javax.inject.Inject;
import org.springframework.http.MediaType;
import uu.app.server.CommandContext;
import uu.app.server.annotation.Command;
import uu.app.server.annotation.CommandController;
import uu.app.server.annotation.DownloadCommand;
import uu.app.server.dto.DownloadableResourceDtoOut;
import uu.demoapp.main.dto.CreateImageDtoIn;
import uu.demoapp.main.dto.GetImageDtoIn;
import uu.demoapp.main.dto.ImageDtoOut;
import uu.demoapp.main.model.ImageModel;

/**
 * Controller contains commands which demonstrate working with uuBinaryStore.
 */
@CommandController
public final class ImageController {

  @Inject
  private ImageModel imageModel;

  @Command(path = "createImage", method = POST, consumes = MediaType.MULTIPART_FORM_DATA_VALUE)
  public ImageDtoOut createBinary(CommandContext<CreateImageDtoIn> ctx) {
    return imageModel.createImage(ctx.getUri().getAwid(), ctx.getDtoIn());
  }

  @DownloadCommand(path = "getImage", method = GET)
  public DownloadableResourceDtoOut getBinaryData(CommandContext<GetImageDtoIn> ucEnv) {
    return imageModel.getImageData(ucEnv.getUri().getAwid(), ucEnv.getDtoIn());
  }
}
'></Plus4U5.Bricks.SourceCode>
      <br/>
      <UU5.Bricks.Em>Ukázka modelu pracujícího s binárními daty v technologii Java.</UU5.Bricks.Em>
      <Plus4U5.Bricks.SourceCode value='import java.io.IOException;
import javax.inject.Inject;
import org.springframework.core.io.InputStreamResource;
import org.springframework.http.MediaType;
import org.springframework.stereotype.Component;
import uu.app.binarystore.exceptions.BinaryStoreIdentityRuntimeException;
import uu.app.binarystore.exceptions.BinaryStoreUnexpectedRuntimeException;
import uu.app.binarystore.dao.BinaryData;
import uu.app.server.dto.ContentDisposition;
import uu.app.server.dto.ContentDispositionType;
import uu.app.server.dto.DownloadableResourceDtoOut;
import uu.demoapp.main.dao.ImageDao;
import uu.demoapp.main.domain.Image;
import uu.demoapp.main.dto.CreateImageDtoIn;
import uu.demoapp.main.dto.ImageDtoOut;
import uu.demoapp.main.exceptions.DemoRuntimeException;

@Component
public final class ImageModel {

  @Inject
  private ImageDao imageDao;

  public ImageDtoOut createImage(String awid, CreateImageDtoIn dtoIn) {
    // Validation and other logic

    // Prepare uuBinaryObject
    Image image = convertToEntity(awid, dtoIn);

    // Send uuBinary object and data stream from dtoIn to Dao
    try {
      image = imageDao.create(image, dtoIn.getData().getInputStream());
    } catch (IOException | BinaryStoreUnexpectedRuntimeException e) {
      throw new DemoRuntimeException(DemoRuntimeException.Error.IMAGE_CREATE_FAILED, "Create image failed.", e);
    }

    // convert result to dtoOut
    return convertToDto(image);
  }

  public DownloadableResourceDtoOut getImageData(String awid, GetImageDtoIn dtoIn) {
    // Validation and other logic

    // Get data from Dao
    BinaryData binaryData = null;
    try {
      binaryData = imageDao.getDataByCode(awid, dtoIn.getCode());
    } catch (BinaryStoreUnexpectedRuntimeException | BinaryStoreIdentityRuntimeException e) {
      throw new DemoRuntimeException(DemoRuntimeException.Error.IMAGE_DOES_NOT_EXIST, "Image does not exist.", e);
    }

    // convert result to downloadable dtoOut
    return convertToDownloadableDtoOut(binaryData, dtoIn.getContentDisposition());
  }

  private DownloadableResourceDtoOut convertToDownloadableDtoOut(BinaryData binaryData, String contentDisposition) {
    ContentDispositionType type = ContentDispositionType.INLINE.asText().equals(contentDisposition) ? ContentDispositionType.INLINE : ContentDispositionType.ATTACHMENT;

    return new DownloadableResourceDtoOut(new InputStreamResource(binaryData.getInputStream()),
        new ContentDisposition(type, null, binaryData.getFilename()),
        binaryData.getSize(),
        MediaType.parseMediaType(binaryData.getContentType()));
  }
}'>
      </Plus4U5.Bricks.SourceCode>
    </UU5.Bricks.Section>
  </UU5.Bricks.Section>
</UU5.Bricks.Lsi.Item>